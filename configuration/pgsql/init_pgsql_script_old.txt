cat <<'EOF' > init_pgsql.sh
#!/usr/bin/env bash
set -euo pipefail

# Optional overrides (export before running to override autodetect)
: "${PG_SERVER:=}"   # e.g., mypg.flexible.postgres.database.azure.com
: "${PG_DB:=appdb}"  # target application database
: "${ROLE_PREFIX:=app_role}"  # base role name if you don't want to use webapp name

echo "Logging in with VM managed identity..." >&2
az login --identity 1>/dev/null

echo "Finding resource group containing 'api'..." >&2
RG=$(az group list --query "[].name" -o tsv | grep -i 'api' | head -n 1 || true)
if [[ -z "${RG}" ]]; then
  echo "ERROR: No resource group found with 'api' in the name." >&2
  exit 1
fi
echo "Resource group: ${RG}" >&2

echo "Finding Web App in RG '${RG}' with 'backend' in the name..." >&2
WEBAPP=$(az webapp list -g "${RG}" --query "[].name" -o tsv | grep -i 'backend' | head -n 1 || true)
if [[ -z "${WEBAPP}" ]]; then
  echo "ERROR: No Web App found in RG '${RG}' with 'backend' in the name." >&2
  exit 1
fi
echo "Web App: ${WEBAPP}" >&2

echo "Reading Web App system-assigned managed identity..." >&2
SYS_MI_PRINCIPAL_ID=$(az webapp identity show -g "${RG}" -n "${WEBAPP}" --query "principalId" -o tsv || true)
if [[ -z "${SYS_MI_PRINCIPAL_ID}" ]]; then
  echo "ERROR: Web App has no system-assigned managed identity." >&2
  exit 1
fi
echo "System-assigned MI principal ID: ${SYS_MI_PRINCIPAL_ID}" >&2

# Choose a Postgres role name from the webapp name (safe chars)
ROLE_NAME=$(echo "${WEBAPP}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_]/_/g')
if [[ -n "${ROLE_PREFIX}" ]]; then
  ROLE_NAME="${ROLE_PREFIX}_${ROLE_NAME}"
fi
echo "Planned Postgres role name: ${ROLE_NAME}" >&2

# Detect Postgres server if not provided
if [[ -z "${PG_SERVER}" ]]; then
  echo "Detecting Postgres server..." >&2
  PG_SERVER=$(az postgres flexible-server list --query "[?resourceGroup=='${RG}'].fullyQualifiedDomainName" -o tsv | head -n 1 || true)
  if [[ -z "${PG_SERVER}" ]]; then
    PG_SERVER=$(az postgres flexible-server list --query "[].fullyQualifiedDomainName" -o tsv | head -n 1 || true)
  fi
fi
if [[ -z "${PG_SERVER}" ]]; then
  echo "ERROR: Could not detect Postgres server; set PG_SERVER env var." >&2
  exit 1
fi
echo "Postgres server FQDN: ${PG_SERVER}" >&2

# Generate SQL
SQL_FILE="mi_grants_${WEBAPP}.sql"
echo "Generating SQL -> ${SQL_FILE}" >&2
{
  echo "-- Run the CREATE PRINCIPAL in the 'postgres' database"
  cat <<EOF2
-- System-assigned MI mapping
select * from pg_catalog.pgaadauth_create_principal_with_oid(
  '${ROLE_NAME}',
  '${SYS_MI_PRINCIPAL_ID}',
  'service',
  false,
  false
);
EOF2

  cat <<'EOF2'
-- Now switch to the target app database and grant least-privilege CRUD
-- Adjust schema if not using 'public'
GRANT CONNECT ON DATABASE appdb TO "ROLE_NAME_PLACEHOLDER";
GRANT USAGE ON SCHEMA public TO "ROLE_NAME_PLACEHOLDER";
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO "ROLE_NAME_PLACEHOLDER";
GRANT USAGE, SELECT, UPDATE ON ALL SEQUENCES IN SCHEMA public TO "ROLE_NAME_PLACEHOLDER";
ALTER DEFAULT PRIVILEGES IN SCHEMA public
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO "ROLE_NAME_PLACEHOLDER";
ALTER DEFAULT PRIVILEGES IN SCHEMA public
  GRANT USAGE, SELECT, UPDATE ON SEQUENCES TO "ROLE_NAME_PLACEHOLDER";
EOF2
} > "${SQL_FILE}"

# Replace placeholder role name
sed -i.bak "s/ROLE_NAME_PLACEHOLDER/${ROLE_NAME}/g" "${SQL_FILE}"
rm -f "${SQL_FILE}.bak"

# Execute SQL automatically using VM's MI (which must be Entra admin)
echo "Executing SQL automatically using the VM's system-assigned managed identity..." >&2
TOKEN=$(az account get-access-token \
  --resource https://ossrdbms-aad.database.windows.net/ \
  --query accessToken -o tsv)

# First run CREATE PRINCIPAL in 'postgres'
PGPASSWORD="$TOKEN" psql \
  "host=${PG_SERVER} dbname=postgres user=kelix sslmode=require" \
  -f "${SQL_FILE}"

# Then run GRANTs in target database
PGPASSWORD="$TOKEN" psql \
  "host=${PG_SERVER} dbname=${PG_DB} user=kelix sslmode=require" \
  -f "${SQL_FILE}"

echo "All steps completed. Managed identity is now mapped in Postgres and granted permissions." >&2
EOF

chmod +x init_pgsql.sh
